<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <script>

        /* 
        배열(array)
            const 배열 = [];     
            
            속성
                배열.length
            메서드
                배열.valueOf() -> 배열 전체 요소 반환

                배열.sort() -> 오름차순 정렬, 123.., 가나다..., abc...
                배열.reverse() -> 거꾸로 -> , sort()한거를 reverse()하면 내림차순이 됨
                배열.toSorted() -> 오름차순 정렬(복제), 원본 손상 없음
                배열.toReversed() -> 거꾸로(복제)
                배열.map() -> 배열의 각 항목에 함수를 실행하고 결과로 새 배열을 반환 할 수 있다.

        
        
        */
 

        // 배열의 값을 저장하는 공간이 5개
        const arr1 = new Array(5);
        console.log(arr1);

        //배열의 값이 5이며, 1개
        const arr2 = [5]; // 배열 리터럴 방식을 사용
        console.log(arr2.valueOf());
        
        //배열의 값이 2개
        const arr11 = new Array(5, 10);
        const arr22 = [5, 10];

        console.log(arr11, arr22);

        //배열 참조
        //배열명[색인번호]
        //색인 번호는 0, 1, 2, 3 ...
        const cards = ["사랑의 하츄핑", 1.5, "2024.08.07", 490];
        document.write("<h2>배열 참조</h2>")
        document.write(cards[0]+"<br>");
        document.write(cards[1]+"<br>");
        document.write(cards[2]+"<br>");
        document.write(cards[3]+"<br>");

        /*const cards2 = cards.map((item)=> return <ul>
            <li>{item}</li>
            <li>{item}</li>
            <li>{item}</li>
        </ul>)
*/
        document.write("<h2>while</h2>");
        //while: 조건이 만족하는 동안 반복
        //초기값
        //while (조건){...
        // 증감값  
        //} 초기값, 증감값 필요
        //무한 반복
        let idx = 0; 
        while(idx<cards.length) {
            document.write(cards[idx]+"<br>");           
            idx++;
        }

        //do~while : 최소 한 번은 실행한다.
        /* 
        초기값
        do{
            ...
            증감값
        } while (조건)        
        
        */
        document.write("<h2>do while</h2>");

        let id = 0; 
        do{
            document.write(cards[id]+"<br>");           
            id++;
        } while(id<cards.length) 

    document.write("<hr>");
    document.write("<h2>for</h2>")
        //반복문 for
        //for(초기값; 조건식; 증감값){반복 명령문}
        for(let i=0; i<cards.length; i++){
            document.write(cards[i]+"<br>");
        }
        document.write("<hr>");
        document.write("<h2>for~ of</h2>")
        //for ~ of
        //for(const x of 배열 또는 컬렉션) {...} x는 값이라 인덱스 찾을 필요 없음. 인덱스 필요 없음
        //x는 요소 자체 item
        //cards[index]는 값
        for(const x of cards) {
            document.write(x+"<br>");
        }
        document.write("<hr>");
        //반복 동작
        //객체.forEach(함수) 매서드
        //배열.forEach((item, index)=>{})

        document.write("<h2>forEach</h2>")
        cards.forEach((item, idx)=>{
            document.write(item+"<br>");
        });

        //map(함수) 메서드
        //문제 : <ul> 안에 <li>로 넣기


            document.write("<hr>");

            

        //배열의 개수
        //document.write(cards.length+"<br>");

        document.write("<h2>map</h2>");
        //배열.map()
document.write(`<ul>`);
cards.map(item =>{
    const myList =`<li>${item}</li>`;
    document.write (myList);
   
});

document.write(`</ul>`);

/* 
정렬(sort)
    오름차순: 가나다, abc, 123...
    내림차순: 다나가, cba, 321...

    배열.sort(함수) -> 오름차순
    배열.sort(함수), reverse() ->내림차순
    배열.toSorted(함수) -> 복제 오름차순
    배열.toReversed(함수)

*/
const sortArr = ["5", "2", "7", "55", "6"];
console.log("정렬전:", sortArr.valueOf());
console.log("정렬후:", sortArr.sort());


//기존 배열을 복제하여 기존 배열 순서는 변경 없음 새로운 정렬 만든다
console.log("정렬전:", sortArr.toSorted((a, b)=>a - b));
//
console.log("정렬후:", sortArr.toReversed((a, b)=>a - b));




    </script>

</body>
</html>